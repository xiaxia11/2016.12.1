###包装对象：（2016.12.1）
 > * 当简单类型去查看某个属性或者方法的时候，系统会偷偷的将这个简单类型转成对象类型的对象，从这个对象去查找要查看的结果，之后，这个包装对象自动销毁，这个对象被销毁的对象为包装对象，整个过程就是就是简单类型也能查看（调用）某个属性和方法的原理。
 ----
> * 第二种两种定义（看个人理解哪种好）
什么是包装对象
		当使用原始类型的值（string、number、boolean），在调用对应属性和方法的时候，内部会自动转成对应的对象。隐式创建的这个对象，就成为包装对象
		内置的对象
			String、Number、Boolean
		包装对象的特点
			隐式创建对象后，可以调用对应的属性和方法，使用后，立马销毁，所以不能给原始类型的值添加属性和方法
		String  -> 字符串
		Array  ->  数组
		Object ->  对象
		Number ->  数字
		
----		
> * 简单类型的属性只能读 不能写（字符串），str.length = 1,(这样是设置不了的)
注意：就算内置对象，也不能随意去修改属性，只能读。

> * hasOwnProperty：
	查看某个属性是不是这个对象自身的。
  * 注意：***自身，一定是在当前这个对象中（不会沿着原型链查找属性，只查找自身属性
	boolean object.hasOwnProperty(prop);

----	
> *因为简单类型的赋值就是赋值
	简单类型的赋值是不会影响另一个数据
而对象类型的赋值是赋址
对象类型赋值都是引用一个内存地址，所以说，改变arr2，同样会改变arr
解决：
	通过循环，将对象中每个简单类型赋值给另一个对象，就不会出现引用关系。